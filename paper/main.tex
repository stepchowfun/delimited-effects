%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document settings and packages %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt]{article}

\usepackage[T1]{fontenc} % The font encoding
\usepackage[framemethod=tikz]{mdframed} % For figures (`tikz` allows us to have a transparent background)
\usepackage[margin=1in]{geometry} % For setting the margin
\usepackage{amssymb} % For \varnothing
\usepackage{bussproofs} % For inference rules
\usepackage{float} % For the [H] option in \begin{figure}[H]. NOTE: Stop using this when we have more content
\usepackage{inconsolata} % Monospace font
\usepackage{listings} % For source code
\usepackage{mathtools} % For \Coloneqq
\usepackage{stackengine} % For stacking axioms
\usepackage{stmaryrd} % For \llbracket and \rrbracket
\usepackage{xcolor}

% Add a "Draft" watermark to the background.
\usepackage{draftwatermark}
\SetWatermarkText{\textsc{Draft}}
\SetWatermarkScale{3}
\SetWatermarkLightness{0.975}

\title{Delimited effects}
\date{}

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source code formatting %
%%%%%%%%%%%%%%%%%%%%%%%%%%

\definecolor{purple}{RGB}{127, 0, 181}

\lstdefinelanguage{gram}{morekeywords={effect, handle}}

\lstset{
  aboveskip=\bigskipamount,
  basicstyle=\ttfamily,
  belowskip=\bigskipamount,
  keepspaces=true,
  keywordstyle=\bfseries\color{purple},
  language=gram,
}

%%%%%%%%%%
% Macros %
%%%%%%%%%%

% Theorem styles
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

% Misc
\newcommand\anno[2]{#1 : \colorEmbellished{#2}}
\newcommand\apply[2]{#1\parens{#2}}
\newcommand\parens[1]{\left( #1 \right)}
\newcommand\fv[1]{\apply{\text{fv}}{#1}}
\newcommand\ftv[1]{\apply{\text{ftv}}{#1}}
\newcommand\eff[1]{\apply{\text{eff}}{#1}}
\newcommand\dom[1]{\apply{\text{dom}}{#1}}
\newcommand\substitute[3]{#1 \left[ #3 / #2 \right]}
\makeatletter
\renewcommand{\boxed}[1]{\text{\kern 0.1em\fboxsep=.2em\fbox{\m@th$\displaystyle#1$}\kern 0.1em}}
\makeatother

% Terms
\newcommand\colorTerm[1]{\textcolor{black}{#1}}
\newcommand\term{t}
\newcommand\eVar{x}
\newcommand\eAbs[2]{\lambda #1 \; . \; #2}
\newcommand\eAbsAnno[3]{\eAbs{\anno{#1}{#2}}{#3}}
\newcommand\eApp[2]{#1 \; #2}
\newcommand\eTAbs[2]{\Lambda \colorType{#1} \; . \; #2}
\newcommand\eTApp[2]{#1 \; \colorType{#2}}
\newcommand\eHandle[3]{\textbf{handle} \; \colorType{#1} \; \textbf{with} \; #2 \; \textbf{in} \; #3}
\newcommand\eEffect[4]{\textbf{effect} \; \colorType{#1} \; \textbf{where} \; \anno{#2}{#3} \; \textbf{in} \; #4}
\newcommand\eAnno[2]{\anno{#1}{\colorType{#2}}}
\newcommand\eDo[3]{\textbf{do} \; #1 \leftarrow #2 \; \textbf{in} \; #3}

% Types
\newcommand\colorType[1]{\textcolor[RGB]{12, 56, 150}{#1}}
\newcommand\type{\tau}
\newcommand\tVar{\alpha}
\newcommand\tArrow[2]{\colorEmbellished{#1} \rightarrow \colorEmbellished{#2}}
\newcommand\tForall[2]{\forall #1 \; . \; \colorEmbellished{#2}}
\newcommand\tEmbellished[2]{\colorEmbellished{\colorType{#1} \; ! \; \colorRow{#2}}}

% Embellished types
\newcommand\colorEmbellished[1]{\textcolor[RGB]{80, 140, 80}{#1}}
\newcommand\embellishedType{\sigma}

% Rows
\newcommand\colorRow[1]{\textcolor[RGB]{150, 26, 12}{#1}}
\newcommand\row{\varepsilon}
\newcommand\rEmpty{\varnothing}
\newcommand\rSingleton[1]{\left\{ \colorType{#1} \right\}}
\newcommand\rUnion[2]{#1 \cup #2}

% Hoisted terms
\newcommand\hoistedTerms{\Delta}
\newcommand\hSingleton[3]{\left\{ #1 \mapsto \anno{#2}{\colorType{#3}} \right\}}
\newcommand\hEmpty{\varnothing}
\newcommand\hUnion[2]{#1 \cup #2}

% Type contexts
\newcommand\context{\Gamma}
\newcommand\cEmpty{\varnothing}
\newcommand\cTExtend[3]{#1, \anno{#2}{#3}}
\newcommand\cKExtend[2]{#1, \colorType{#2}}

% Effect map
\newcommand\effectMap{\Sigma}
\newcommand\emEmpty{\varnothing}
\newcommand\emExtend[3]{#1, \colorType{#2} \mapsto \colorEmbellished{#3}}

% Judgments
\newcommand\subrowSym{\subseteq}
\newcommand\nSubrowSym{\nsubseteq}
\newcommand\subrow[2]{\colorRow{#1} \subrowSym \colorRow{#2}}
\newcommand\nSubrow[2]{\colorRow{#1} \nSubrowSym \colorRow{#2}}
\newcommand\checkType[6]{#1 ; #2 \vdash #3 \Downarrow \colorType{#4} \; | \; #5; #6}
\newcommand\inferType[6]{#1 ; #2 \vdash #3 \Uparrow \colorType{#4} \; | \; #5; #6}
\newcommand\checkOrInferType[5]{#1 ; #2 \vdash #3 \Updownarrow \colorType{#4} \; | \; #5}
\newcommand\hasType[4]{#1 ; #2 \vdash \anno{#3}{#4}}
\newcommand\fresh[1]{#1 \; \text{fresh}}

%%%%%%%%%%%%%%%%%%%%%
% The specification %
%%%%%%%%%%%%%%%%%%%%%

\begin{document}
  \maketitle

  \begin{abstract}
    We introduce delimited effects, a modest type and effect system capable of modeling a diverse collection of programming language features including algebraic effects, type classes, and dynamic scoping.
  \end{abstract}

  \section{Introduction}

    \iffalse
      \begin{lstlisting}[gobble=4]
        effect IO
          getLine   : String ! IO
          printLine : String -> () ! IO
      \end{lstlisting}

      \begin{lstlisting}[gobble=4]
        effect Monoid a
          mempty  : a ! Monoid a
          mappend : a -> a -> a ! Monoid a
      \end{lstlisting}
    \fi

  \section{Overview}

    \subsection{The core language}

      \subsubsection{Syntax}

        \begin{figure}[H]
          \begin{mdframed}[backgroundcolor=none]
            \begin{center}
              \begin{tabular}{l l l}
                $\term \Coloneqq$ & & terms: \\
                & $\eVar$ & variable \\
                & $\eAbsAnno{\eVar}{\embellishedType}{\term}$ & abstraction \\
                & $\eApp{\term}{\term}$ & application \\
                & $\eTAbs{\tVar}{\term}$ & type abstraction \\
                & $\eTApp{\term}{\type}$ & type application \\
                & $\eEffect{\tVar}{\eVar}{\embellishedType}{\term}$ & effect definition \\
                & $\eHandle{\tVar}{\term}{\term}$ & effect handler \\
                & $\eDo{\eVar}{\term}{\term}$ & sequence \\
                \\
                $\colorType{\type} \Coloneqq$ & & types: \\
                & $\colorType{\tVar}$ & type variable \\
                & $\colorType{\tArrow{\embellishedType}{\embellishedType}}$ & arrow type \\
                & $\colorType{\tForall{\tVar}{\embellishedType}}$ & universal type \\
                \\
                $\colorEmbellished{\embellishedType} \Coloneqq$ & & embellished types: \\
                & $\colorType{\tEmbellished{\type}{\row}}$ & type with effects \\
                \\
                $\colorRow{\row} \Coloneqq$ & & rows: \\
                & $\colorRow{\rEmpty}$ & empty row \\
                & $\colorRow{\rSingleton{\tVar}}$ & singleton row \\
                & $\colorRow{\rUnion{\row}{\row}}$ & row union \\
                \\
                $\context \Coloneqq$ & & contexts: \\
                & $\cEmpty$ & empty context \\
                & $\cTExtend{\context}{\eVar}{\embellishedType}$ & variable binding \\
                & $\cKExtend{\context}{\tVar}$ & type variable binding \\
                \\
                $\effectMap \Coloneqq$ & & effect maps: \\
                & $\emEmpty$ & empty effect map \\
                & $\emExtend{\effectMap}{\tVar}{\embellishedType}$ & effect binding \\
              \end{tabular}
            \end{center}

            \caption{Syntax of the core language}\label{fig:core_syntax}
          \end{mdframed}
        \end{figure}

      \subsubsection{Row subsumption}

        \begin{figure}[H]
          \begin{mdframed}[backgroundcolor=none]
            \begin{center}
              \framebox{$\subrow{\row}{\row}$}
            \end{center}

            \medskip

            \begin{prooftree}
                \AxiomC{}
              \RightLabel{(\textsc{R-Empty})}
              \UnaryInfC{$\subrow{\rEmpty}{\row}$}
            \end{prooftree}

            \begin{prooftree}
                \AxiomC{}
              \RightLabel{(\textsc{R-SingletonRefl})}
              \UnaryInfC{$\subrow{\rSingleton{\tVar}}{\rSingleton{\tVar}}$}
            \end{prooftree}

            \begin{prooftree}
                \AxiomC{$\subrow{\rSingleton{\tVar}}{\row_1}$}
              \RightLabel{(\textsc{R-SingletonLeft})}
              \UnaryInfC{$\subrow{\rSingleton{\tVar}}{\rUnion{\row_1}{\row_2}}$}
            \end{prooftree}

            \begin{prooftree}
                \AxiomC{$\subrow{\rSingleton{\tVar}}{\row_2}$}
              \RightLabel{(\textsc{R-SingletonRight})}
              \UnaryInfC{$\subrow{\rSingleton{\tVar}}{\rUnion{\row_1}{\row_2}}$}
            \end{prooftree}

            \begin{prooftree}
                \AxiomC{$\subrow{\row_1}{\row_3}$}
                \AxiomC{$\subrow{\row_2}{\row_3}$}
              \RightLabel{(\textsc{R-Union})}
              \BinaryInfC{$\subrow{\rUnion{\row_1}{\row_2}}{\row_3}$}
            \end{prooftree}

            \caption{Row subsumption}\label{fig:row_subsumption}
          \end{mdframed}
        \end{figure}

      \subsubsection{Typing}

        In the following rules, terms are considered equivalent up to $\alpha$-conversion, and likewise for types. Effect row union is considered associative and commutative.

        \begin{figure}[H]
          \begin{mdframed}[backgroundcolor=none]
            \begin{center}
              \framebox{$\hasType{\context}{\effectMap}{\term}{\embellishedType}$}
            \end{center}

            \medskip

            \begin{prooftree}
                \AxiomC{$\colorEmbellished{\embellishedType} = \colorEmbellished{\apply{\context}{\colorTerm{\eVar}}}$}
              \RightLabel{(\textsc{T-Var})}
              \UnaryInfC{$\hasType{\context}{\effectMap}{\eVar}{\embellishedType}$}
            \end{prooftree}

            \begin{prooftree}
                \AxiomC{$\hasType{\cTExtend{\context}{\eVar}{\embellishedType_2}}{\effectMap}{\term}{\embellishedType_1}$}
              \RightLabel{(\textsc{T-Abs})}
              \UnaryInfC{$\hasType{\context}{\effectMap}{\eAbsAnno{\eVar}{\embellishedType_2}{\term}}{\tEmbellished{\parens{\tArrow{\embellishedType_2}{\embellishedType_1}}}{\rEmpty}}$}
            \end{prooftree}

            \begin{prooftree}
              \AxiomC{$\hasType{\context}{\effectMap}{\term_1}{\tEmbellished{\parens{\tArrow{\embellishedType_2}{\embellishedType_1}}}{\rEmpty}}$}
                \AxiomC{$\hasType{\context}{\effectMap}{\term_2}{\embellishedType_2}$}
              \RightLabel{(\textsc{T-App})}
              \BinaryInfC{$\hasType{\context}{\effectMap}{\eApp{\term_1}{\term_2}}{\embellishedType_1}$}
            \end{prooftree}

            \begin{prooftree}
                \AxiomC{$\colorType{\tVar} \notin \dom{\context}$}
                \AxiomC{$\hasType{\cKExtend{\context}{\tVar}}{\effectMap}{\term}{\embellishedType}$}
              \RightLabel{(\textsc{T-TAbs})}
              \BinaryInfC{$\hasType{\context}{\effectMap}{\eTAbs{\tVar}{\term}}{\tEmbellished{\parens{\tForall{\tVar}{\embellishedType}}}{\rEmpty}}$}
            \end{prooftree}

            \begin{prooftree}
              \AxiomC{$\hasType{\context}{\effectMap}{\term}{\tEmbellished{\parens{\tForall{\tVar}{\embellishedType}}}{\rEmpty}}$}
              \RightLabel{(\textsc{T-TApp})}
              \UnaryInfC{$\hasType{\context}{\effectMap}{\eTApp{\term}{\type}}{\substitute{\embellishedType}{\colorType{\tVar}}{\colorType{\type}}}$}
            \end{prooftree}

            \begin{prooftree}
                \AxiomC{$\hasType{\cTExtend{\context}{\eVar}{\embellishedType_1}}{\emExtend{\effectMap}{\tVar}{\embellishedType_1}}{\term}{\embellishedType_2}$}
              \RightLabel{(\textsc{T-Effect})}
              \UnaryInfC{$\hasType{\context}{\effectMap}{\eEffect{\tVar}{\eVar}{\embellishedType_1}{\term}}{\embellishedType_2}$}
            \end{prooftree}

            \begin{prooftree}
                \AxiomC{\Shortstack[c]{
                  {$\colorEmbellished{\embellishedType_1} = \colorEmbellished{\apply{\effectMap}{\colorType{\tVar}}}$}
                  {$\colorEmbellished{\embellishedType_2} = \colorEmbellished{\substitute{\embellishedType_1}{\colorRow{\rSingleton{\tVar}}}{\colorRow{\row_1}}}$}
                  {$\hasType{\context}{\effectMap}{\term_1}{\embellishedType_2}$}
                  {$\hasType{\context}{\effectMap}{\term_2}{\tEmbellished{\type_1}{\rUnion{\row_1}{\rSingleton{\tVar}}}}$}
                }}
              \RightLabel{(\textsc{T-Handle})}
              \UnaryInfC{$\hasType{\context}{\effectMap}{\eHandle{\tVar}{\term_1}{\term_2}}{\tEmbellished{\type_1}{\row_1}}$}
            \end{prooftree}

            \begin{prooftree}
                \AxiomC{$\hasType{\context}{\effectMap}{\term_1}{\tEmbellished{\type_1}{\row_1}}$}
                \AxiomC{$\hasType{\cTExtend{\context}{\eVar}{\tEmbellished{\type_1}{\rEmpty}}}{\effectMap}{\term_2}{\tEmbellished{\type_2}{\row_2}}$}
              \RightLabel{(\textsc{T-Do})}
              \BinaryInfC{$\hasType{\context}{\effectMap}{\eDo{\eVar}{\term_1}{\term_2}}{\tEmbellished{\type_2}{\rUnion{\row_1}{\row_2}}}$}
            \end{prooftree}

            \begin{prooftree}
              \AxiomC{$\hasType{\context}{\effectMap}{\term}{\tEmbellished{\type}{\row_1}}$}
                \AxiomC{$\subrow{\row_1}{\row_2}$}
              \RightLabel{(\textsc{T-SubRow})}
              \BinaryInfC{$\hasType{\context}{\effectMap}{\term}{\tEmbellished{\type}{\row_2}}$}
            \end{prooftree}

            \caption{Typing rules for the core language}\label{fig:core_typing}
          \end{mdframed}
        \end{figure}

    \subsection{The source language}

      \subsubsection{Syntax}

        \begin{figure}[H]
          \begin{mdframed}[backgroundcolor=none]
            \begin{center}
              \begin{tabular}{l l l}
                $\term \Coloneqq$ & & terms: \\
                & $\eVar$ & variable \\
                & $\eAbs{\eVar}{\term}$ & abstraction \\
                & $\eApp{\term}{\term}$ & application \\
                & $\eTAbs{\tVar}{\term}$ & type abstraction \\
                & $\eTApp{\term}{\type}$ & type application \\
                & $\eEffect{\tVar}{\eVar}{\embellishedType}{\term}$ & effect definition \\
                & $\eHandle{\tVar}{\term}{\term}$ & effect handler \\
                & $\eAnno{\term}{\type}$ & type annotation \\
                \\
                $\hoistedTerms \Coloneqq$ & & hoisted term maps: \\
                & $\hEmpty$ & empty hoisted term map \\
                & $\hSingleton{\eVar}{\term}{\type}$ & singleton hoisted term map \\
                & $\hUnion{\hoistedTerms}{\hoistedTerms}$ & hoisted term map union \\
              \end{tabular}
            \end{center}

            \caption{Syntax for terms of the source language}\label{fig:source_syntax}
          \end{mdframed}
        \end{figure}

\end{document}
