%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document settings and packages %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt]{article}

\usepackage[framemethod=tikz]{mdframed} % For figures (`tikz` allows us to have a transparent background)
\usepackage[margin=1in]{geometry} % For setting the margin
\usepackage{amssymb} % For \varnothing
\usepackage{bussproofs} % For inference rules
\usepackage{listings} % For source code
\usepackage{mathtools} % For \Coloneqq
\usepackage{stackengine} % For stacking axioms
\usepackage{stmaryrd} % For \llbracket and \rrbracket
\usepackage{inconsolata} % Monospace font
\usepackage[T1]{fontenc} % The font encoding

% Add a "Draft" watermark to the background.
\usepackage{draftwatermark}
\SetWatermarkText{\textsc{Draft}}
\SetWatermarkScale{3}
\SetWatermarkLightness{0.975}

\title{Delimited effects}
\date{}

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source code formatting %
%%%%%%%%%%%%%%%%%%%%%%%%%%

\definecolor{purple}{RGB}{127, 0, 181}

\lstdefinelanguage{gram}{morekeywords={effect, provide}}

\lstset{
  aboveskip=\bigskipamount,
  basicstyle=\ttfamily,
  belowskip=\bigskipamount,
  keepspaces=true,
  keywordstyle=\bfseries\color{purple},
  language=gram,
}

%%%%%%%%%%
% Macros %
%%%%%%%%%%

% Theorem styles
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

% Misc
\newcommand\anno[2]{#1 : #2}
\newcommand\dom[1]{\text{dom}\parens{#1}}
\newcommand\lstof[1]{\overline{#1}}
\newcommand\parens[1]{\left( #1 \right)}
\newcommand\sub[3]{#1 \left[ #2 \mapsto #3 \right]}
\newcommand\freevars[1]{\text{free}\parens{#1}}

% Terms
\newcommand\term{t}
\newcommand\eunit{()}
\newcommand\evar{x}
\newcommand\eabs[2]{\lambda #1 \; . \; #2}
\newcommand\eapp[2]{#1 \; #2}
\newcommand\etabs[2]{\lambda #1 \; . \; #2}
\newcommand\etapp[2]{#1 \; #2}
\newcommand\eeffect[3]{\textbf{effect} \; \anno{#1}{#2} \; \textbf{in} \; #3}
\newcommand\eprovide[4]{\textbf{provide} \; #1 \; \textbf{with} \; #2 = #3 \; \textbf{in} \; #4}

% Types
\newcommand\type{\sigma}
\newcommand\tptwithr[2]{#1 \; ! \; #2}
\newcommand\tvar{\alpha}
\newcommand\tabs[2]{\lambda #1 \; . \; #2}
\newcommand\tapp[2]{#1 \; #2}
\newcommand\teffect[3]{\mu #1 \; . \; \left\langle\anno{#2}{#3}\right\rangle}

% Proper types
\newcommand\properType{\tau}
\newcommand\ptunit{1}
\newcommand\ptarrow[2]{#1 \rightarrow #2}
\newcommand\ptforall[2]{\forall #1 \; . \; #2}

% Effect rows
\newcommand\row{\varepsilon}
\newcommand\rempty{\varnothing_{\row}}
\newcommand\rsingleton[1]{\left\{ #1 \right\}}
\newcommand\runion[2]{#1, #2}
\newcommand\rdiff[2]{#1 \; - \; #2}

% Type contexts
\newcommand\context{\Gamma}
\newcommand\cempty{\varnothing_{\context}}
\newcommand\ceextend[2]{#1, #2}
\newcommand\csextend[2]{#1, #2}
\newcommand\clookup[2]{#1\parens{#2}}

% Judgements
\newcommand\tjudgment[3]{#1 \vdash \anno{#2}{#3}}
\newcommand\opwellformed[3]{#1 \vdash #2 \; \triangleright \; #3}
\newcommand\subtype[3]{#1 \vdash #2 \; \sqsubseteq \; #3}
\newcommand\subsumes[3]{#1 \vdash #2 \; \sqsubseteq \; #3}

%%%%%%%%%%%%%%%%%%%%%
% The specification %
%%%%%%%%%%%%%%%%%%%%%

\begin{document}
  \maketitle

  \begin{abstract}
    We introduce delimited effects, a modest type and effect system capable of modeling a diverse collection of programming language features including algebraic effects, type classes, and dynamic scoping.
  \end{abstract}

  \section{Introduction}

  The system we describe in this paper is motivated by the observation that a variety of seemingly orthogonal ideas in programming languages are variations on a common theme: tracking predicates in the type system without requiring the explicit threading of witnesses through the program at the term level. A sufficiently smart inference algorithm frees the programmer from the ceremony of annotating types and propagating predicates. There's no shortage of examples of this theme: type classes, implicit parameters, algebraic effects, etc. In this paper, we generalize these ideas by a single language construct, which we call \emph{delimited effects}.

  Our primary contributions are:

  \begin{itemize}
    \item We give the syntax, semantics, and typing rules for our system.
    \item We prove that the typing rules are sound with respect to the semantics.
    \item We provide one of many possible type inference algorithms for the system.
    \item We provide several diverse examples of programming language features which are generalized by our system.
  \end{itemize}

  \section{Overview}

  \begin{lstlisting}[gobble=4]
    effect IO
      getLine   : String ! IO
      printLine : String -> () ! IO
  \end{lstlisting}

  \begin{lstlisting}[gobble=4]
    effect Monoid a
      mempty  : a ! Monoid a
      mappend : a -> a -> a ! Monoid a
  \end{lstlisting}

  \begin{figure}
    \begin{mdframed}[backgroundcolor=none]
      \begin{center}
        \begin{tabular}{l l l}
          $\term \Coloneqq $ & & terms: \\
          & $\eunit$ & unit \\
          & $\evar$ & variable \\
          & $\eabs{\anno{\evar}{\type}}{\term}$ & abstraction \\
          & $\eapp{\term}{\term}$ & application \\
          & $\etabs{\tvar}{\term}$ & type abstraction \\
          & $\etapp{\term}{\type}$ & type application \\
          & $\eprovide{\term}{\evar}{\term}{\term}$ & effect definition \\
          \\
          $\type \Coloneqq$ & & types: \\
          & $\tptwithr{\properType}{\row}$ & proper type with effects \\
          & $\tvar$ & type variable \\
          & $\row$ & effect row \\
          \\
          $\properType \Coloneqq$ & & proper types: \\
          & $\ptunit$ & unit type \\
          & $\ptarrow{\type}{\type}$ & arrow type \\
          & $\ptforall{\tvar}{\type}$ & quantified type \\
          \\
          $\row \Coloneqq$ & & effect rows: \\
          & $\rempty$ & empty effect row \\
          & $\rsingleton{\term}$ & singleton effect row \\
          & $\runion{\row}{\row}$ & effect row union \\
          \\
          $\context \Coloneqq$ & & contexts: \\
          & $\cempty$ & empty context \\
          & $\ceextend{\context}{\anno{\evar}{\type}}$ & term variable binding \\
        \end{tabular}
      \end{center}

      \caption{Syntax}\label{fig:syntax}
    \end{mdframed}
  \end{figure}

  \begin{figure}
    \begin{mdframed}[backgroundcolor=none]
      \begin{center}
        \framebox{$\tjudgment{\context}{\term}{\type}$}
      \end{center}

      \medskip

      \begin{prooftree}
          \AxiomC{}
        \RightLabel{(\textsc{T-Unit})}
        \UnaryInfC{$\tjudgment{\context}{\eunit}{\tptwithr{\ptunit}{\rempty}}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\clookup{\context}{\evar} = \type$}
        \RightLabel{(\textsc{T-Variable})}
        \UnaryInfC{$\tjudgment{\context}{\evar}{\type}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\tjudgment{\ceextend{\context}{\anno{\evar}{\type_1}}}{\term}{\type_2}$}
        \RightLabel{(\textsc{T-Abstraction})}
        \UnaryInfC{$\tjudgment{\context}{\parens{\eabs{\anno{\evar}{\type_1}}{\term}}}{\tptwithr{\parens{\ptarrow{\type_1}{\type_2}}}}{\rempty}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{\Shortstack[c]{{$\tjudgment{\context}{\term_1}{\tptwithr{\properType_1}{\row_1}}$}
            {$\tjudgment{\context}{\term_2}{\tptwithr{\parens{\ptarrow{\tptwithr{\properType_2}{\row_2}}{\tptwithr{\properType_3}{\row_3}}}}{\row_4}}$}
            {$\subtype{\context}{\tptwithr{\properType_1}{\row_1}}{\tptwithr{\properType_2}{\row_2}}$}}}
        \RightLabel{(\textsc{T-Application})}
        \UnaryInfC{$\tjudgment{\context}{\eapp{\term_2}{\term_1}}{\tptwithr{\properType_3}{\runion{\row_3}{\row_4}}}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\tjudgment{\context}{\term}{\type}$}
        \RightLabel{(\textsc{T-TypeAbstraction})}
        \UnaryInfC{$\tjudgment{\context}{\parens{\etabs{\tvar}{\term}}}{\tptwithr{\parens{\ptforall{\tvar}{\type}}}}{\rempty}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\tjudgment{\context}{\term}{\tptwithr{\parens{\ptforall{\tvar}{\type_2}}}}{\rempty}$}
        \RightLabel{(\textsc{T-TypeApplication})}
        \UnaryInfC{$\tjudgment{\context}{\etapp{\term}{\type_1}}{\sub{\type_2}{\tvar}{\type_1}}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{\Shortstack[c]{{$\opwellformed{\context}{\type_1}{\evar_2}$}
            {$\evar_1 \notin \freevars{\type_2}$}
            {$\tjudgment{\ceextend{\csextend{\context}{\anno{\evar_1}{\tptwithr{\parens{\ptforall{\lstof{\tvar^i}}{\teffect{\evar_2}{\evar_3}{\type_1}}}}{\rempty}}}}{\anno{\evar_3}{\tptwithr{\parens{\ptforall{\lstof{\tvar^i}}{\sub{\type_1}{\evar_2}{\etapp{\evar_1}{\lstof{\tvar^i}}}}}}}{\rempty}}}{\term}{\type_2}$}}}
        \RightLabel{(\textsc{T-Effect})}
        \UnaryInfC{$\tjudgment{\context}{\parens{\eeffect{\evar_1}{\tptwithr{\parens{\ptforall{\lstof{\tvar^i} }{\teffect{\evar_2}{\evar_3}{\type_1}}}}{\rempty}}{\term}}}{\type_2}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{\Shortstack[c]{{$\tjudgment{\context}{\term_1}{\type_1}$}
            {$\tjudgment{\context}{\term_2}{\tptwithr{\properType}{\row}}$}
            {$\tjudgment{\context}{\term_3}{\teffect{\evar_2}{\evar_1}{\type_3}}$}
            {$\subtype{\context}{\type_1}{\sub{\type_3}{\evar_2}{\term_3}}$}}}
        \RightLabel{(\textsc{T-Provide})}
        \UnaryInfC{$\tjudgment{\context}{\parens{\eprovide{\term_3}{\evar_1}{\term_1}{\term_2}}}{\tptwithr{\properType}\rdiff{\row}{\rsingleton{\term_3}}}$}
      \end{prooftree}

      \caption{Typing rules}\label{fig:typing_rules}
    \end{mdframed}
  \end{figure}

  \begin{figure}
    \begin{mdframed}[backgroundcolor=none]
      \begin{center}
        \framebox{$\opwellformed{\context}{\type}{\evar}$}
      \end{center}

      \medskip

      \begin{prooftree}
          \AxiomC{$\opwellformed{\context}{\type_2}{\evar}$}
        \RightLabel{(\textsc{WF-Arrow})}
        \UnaryInfC{$\opwellformed{\context}{\tptwithr{\parens{\ptarrow{\type_1}{\type_2}}}{\row}}{\evar}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\opwellformed{\context}{\type}{\evar}$}
        \RightLabel{(\textsc{WF-ForAll})}
        \UnaryInfC{$\opwellformed{\context}{\tptwithr{\parens{\ptforall{\tvar}{\type}}}{\row}}{\evar}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\subtype{\context}{\rsingleton{\evar}}{\row}$}
        \RightLabel{(\textsc{WF-PureTypeWithEffects})}
        \UnaryInfC{$\opwellformed{\context}{\tptwithr{\properType}{\row}}{\evar}$}
      \end{prooftree}

      \caption{Operation type well-formedness}\label{fig:operation_type_well_formedness}
    \end{mdframed}
  \end{figure}

  \begin{figure}
    \begin{mdframed}[backgroundcolor=none]
      \begin{center}
        \framebox{$\subtype{\context}{\type}{\type}$}
      \end{center}

      \medskip

      \begin{prooftree}
          \AxiomC{}
        \RightLabel{(\textsc{ST-Reflexivity})}
        \UnaryInfC{$\subtype{\context}{\type}{\type}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\subtype{\context}{\type_1}{\type_2}$}
          \AxiomC{$\subtype{\context}{\type_2}{\type_3}$}
        \RightLabel{(\textsc{ST-Transitivity})}
        \BinaryInfC{$\subtype{\context}{\type_1}{\type_3}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\subsumes{\context}{\row_1}{\row_2}$}
        \RightLabel{(\textsc{ST-Unit})}
        \UnaryInfC{$\subsumes{\context}{\tptwithr{\ptunit}{\row_1}}{\tptwithr{\ptunit}{\row_2}}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\subtype{\context}{\type_3}{\type_1}$}
          \AxiomC{$\subtype{\context}{\type_2}{\type_4}$}
          \AxiomC{$\subsumes{\context}{\row_1}{\row_2}$}
        \RightLabel{(\textsc{ST-Arrow})}
        \TrinaryInfC{$\subtype{\context}{\tptwithr{\parens{\ptarrow{\type_1}{\type_2}}}{\row_1}}{\tptwithr{\parens{\ptarrow{\type_3}{\type_4}}}{\row_2}}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\subtype{\context}{\type_1}{\type_2}$}
          \AxiomC{$\subsumes{\context}{\row_1}{\row_2}$}
        \RightLabel{(\textsc{ST-ForAll})}
        \BinaryInfC{$\subtype{\context}{\tptwithr{\parens{\ptforall{\tvar}{\type_1}}}{\row_1}}{\tptwithr{\parens{\ptforall{\tvar}{\type_2}}}{\row_2}}$}
      \end{prooftree}

      \caption{Subtyping}\label{fig:subtyping}
    \end{mdframed}
  \end{figure}

  \begin{figure}
    \begin{mdframed}[backgroundcolor=none]
      \begin{center}
        \framebox{$\subsumes{\context}{\row}{\row}$}
      \end{center}

      \medskip

      \begin{prooftree}
          \AxiomC{}
        \RightLabel{(\textsc{RS-Reflexivity})}
        \UnaryInfC{$\subsumes{\context}{\row}{\row}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\subsumes{\context}{\row_1}{\row_2}$}
          \AxiomC{$\subsumes{\context}{\row_2}{\row_3}$}
        \RightLabel{(\textsc{RS-Transitivity})}
        \BinaryInfC{$\subsumes{\context}{\row_1}{\row_3}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{}
        \RightLabel{(\textsc{RS-Empty})}
        \UnaryInfC{$\subsumes{\context}{\rempty}{\row}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{$\subsumes{\context}{\row_1}{\row_3}$}
          \AxiomC{$\subsumes{\context}{\row_2}{\row_3}$}
        \RightLabel{(\textsc{RS-Union})}
        \BinaryInfC{$\subsumes{\context}{\runion{\row_1}{\row_2}}{\row_3}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{}
        \RightLabel{(\textsc{RS-WeakeningLeft})}
        \UnaryInfC{$\subsumes{\context}{\row_1}{\runion{\row_1}{\row_2}}$}
      \end{prooftree}

      \begin{prooftree}
          \AxiomC{}
        \RightLabel{(\textsc{RS-WeakeningRight})}
        \UnaryInfC{$\subsumes{\context}{\row_2}{\runion{\row_1}{\row_2}}$}
      \end{prooftree}

      \caption{Effect row subsumption}\label{fig:subsumption}
    \end{mdframed}
  \end{figure}

  \begin{definition}[Effect row membership]
    Let $\type \in \row$ be the smallest relation satisfying
    \begin{enumerate}
      \item $\type \in \rsingleton{\type}$
      \item if $\type \in \row_1$ then $\type \in \runion{\row_1}{\row_2}$
      \item if $\type \in \row_2$ then $\type \in \runion{\row_1}{\row_2}$.
    \end{enumerate}
  \end{definition}

  \begin{theorem}[Effect row subtyping]
    Given any two effect rows $\row_1, \row_2$, the following are equivalent:
    \begin{enumerate}
      \item $\subsumes{\context}{\row_1}{\row_2}$
      \item $\forall \type \;.\; \type \in \row_1 \implies \type \in \row_2$.
    \end{enumerate}
  \end{theorem}

\end{document}
