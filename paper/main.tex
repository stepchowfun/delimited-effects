%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document settings and packages %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt]{article}

\usepackage[T1]{fontenc} % The font encoding
\usepackage[framemethod=tikz]{mdframed} % For figures (`tikz` allows us to have a transparent background)
\usepackage[margin=1in]{geometry} % For setting the margin
\usepackage{amssymb} % For \varnothing
\usepackage{bussproofs} % For inference rules
\usepackage{float} % For the [H] option in \begin{figure}[H]. NOTE: Stop using this when we have more content
\usepackage{inconsolata} % Monospace font
\usepackage{listings} % For source code
\usepackage{mathtools} % For \Coloneqq
\usepackage{stackengine} % For stacking axioms
\usepackage{stmaryrd} % For \llbracket and \rrbracket
\usepackage{xcolor}

% Add a "Draft" watermark to the background.
\usepackage{draftwatermark}
\SetWatermarkText{\textsc{Draft}}
\SetWatermarkScale{3}
\SetWatermarkLightness{0.975}

\title{Delimited effects}
\date{}

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source code formatting %
%%%%%%%%%%%%%%%%%%%%%%%%%%

\definecolor{purple}{RGB}{127, 0, 181}

\lstdefinelanguage{gram}{morekeywords={effect, provide}}

\lstset{
  aboveskip=\bigskipamount,
  basicstyle=\ttfamily,
  belowskip=\bigskipamount,
  keepspaces=true,
  keywordstyle=\bfseries\color{purple},
  language=gram,
}

%%%%%%%%%%
% Macros %
%%%%%%%%%%

% Theorem styles
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

% Misc
\newcommand\anno[2]{#1 : #2}
\newcommand\apply[2]{#1\parens{#2}}
\newcommand\parens[1]{\left( #1 \right)}
\newcommand\substitute[3]{#1 \left[ #2 \mapsto #3 \right]}

% Terms
\newcommand\term{t}
\newcommand\eUnit{\texttt{()}}
\newcommand\eVar{x}
\newcommand\eAbs[2]{\lambda #1 \; . \; #2}
\newcommand\eApp[2]{#1 \; #2}
\newcommand\eProvide[4]{\textbf{provide} \; #1 / #2 \; \textbf{with} \; #3 \; \textbf{in} \; #4}

% Types
\newcommand\type{\tau}
\newcommand\tUnit{1}
\newcommand\tArrow[2]{#1 \rightarrow #2}
\newcommand\tEmbellished[2]{{#1}^{\textcolor{violet}{#2}}}

% Rows
\newcommand\row{\varepsilon}
\newcommand\rEmpty{\varnothing_{\row}}
\newcommand\rSingleton[1]{\left\{ #1 \right\}}
\newcommand\rUnion[2]{#1 \cup #2}
\newcommand\rDiff[2]{#1 \setminus #2}

% Boolean rings
\newcommand\brLang{\mathcal{R}}
\newcommand\brEmbed[1]{\mathcal{N}\parens{#1}}
\newcommand\brTerm{e}
\newcommand\brVar{z}
\newcommand\brZero{0}
\newcommand\brOne{1}
\newcommand\brAdd[2]{#1 \; \oplus \; #2}
\newcommand\brMul[2]{#1 \; \cdot \; #2}

% Type contexts
\newcommand\context{\Gamma}
\newcommand\cEmpty{\varnothing_{\context}}
\newcommand\cExtend[2]{#1, #2}

% Effect map
\newcommand\effect{e}
\newcommand\effectMap{E}
\newcommand\emMap[2]{#1 :: #2}
\newcommand\emEmpty{\varnothing_{\effectMap}}
\newcommand\emExtend[2]{#1, #2}

% Judgments
\newcommand\subrowSym{\sqsubseteq}
\newcommand\subtypeSym{\leq}
\newcommand\subrow[2]{#1 \subrowSym #2}
\newcommand\subtype[2]{#1 \subtypeSym #2}
\newcommand\hasType[3]{#1 \vdash \anno{#2}{#3}}
\newcommand\eWellFormed[1]{#1 \; \text{well-formed effect}}

%%%%%%%%%%%%%%%%%%%%%
% The specification %
%%%%%%%%%%%%%%%%%%%%%

\begin{document}
  \maketitle

  \begin{abstract}
    We introduce delimited effects, a modest type and effect system capable of modeling a diverse collection of programming language features including algebraic effects, type classes, and dynamic scoping.
  \end{abstract}

  \section{Introduction}

    \iffalse
      \begin{lstlisting}[gobble=4]
        effect IO
          getLine   : String ! IO
          printLine : String -> () ! IO
      \end{lstlisting}

      \begin{lstlisting}[gobble=4]
        effect Monoid a
          mempty  : a ! Monoid a
          mappend : a -> a -> a ! Monoid a
      \end{lstlisting}
    \fi

  \section{Overview}

    \subsection{Syntax}

      \begin{figure}[H]
        \begin{mdframed}[backgroundcolor=none]
          \begin{center}
            \begin{tabular}{l l l}
              $\term \Coloneqq $ & & terms: \\
              & $\eUnit$ & unit \\
              & $\eVar$ & variable \\
              & $\eAbs{\anno{\eVar}{\type}}{\term}$ & abstraction \\
              & $\eApp{\term}{\term}$ & application \\
              & $\eProvide{\effect}{\overline{\effect_i}}{\term}{\term}$ & effect definition \\
              \\
              $\type \Coloneqq$ & & types: \\
              & $\tUnit$ & unit type \\
              & $\tArrow{\type}{\tEmbellished{\type}{\row}}$ & arrow type \\
              \\
              $\row \Coloneqq$ & & rows: \\
              & $\rEmpty$ & empty row \\
              & $\rSingleton{\effect}$ & singleton row \\
              & $\rUnion{\row}{\row}$ & row union \\
              & $\rDiff{\row}{\row}$ & row difference \\
              \\
              $\context \Coloneqq$ & & contexts: \\
              & $\cEmpty$ & empty context \\
              & $\cExtend{\context}{\anno{\eVar}{\tEmbellished{\type}{\row}}}$ & variable binding \\
              \\
              $\effectMap \Coloneqq$ & & effect map: \\
              & $\emEmpty$ & empty effect map \\
              & $\emExtend{\effectMap}{\emMap{\effect}{\tEmbellished{\type}{\row}}}$ & effect binding \\
            \end{tabular}
          \end{center}

          \caption{Syntax}\label{fig:syntax}
        \end{mdframed}
      \end{figure}

    \subsection{Subtyping}

      An effect row $\row$ models a set of effects $\effect$ constructed by a finite number of unions and relative complements. We define a relation $\subrowSym$ for modeling set inclusion on effect rows.

      The algorithm defining $\subrowSym$ takes two effect rows $\row_1$ and $\row_2$, and constructs a normal form for the effect row $\rDiff{\row_2}{\row_1}$. Normal forms may be compared for equality, and are built in the following language:

      \begin{center}
        $\brTerm \Coloneqq \brZero \mathrel{|} \brOne \mathrel{|} \brVar \mathrel{|} \brMul{\brTerm}{\brTerm} \mathrel{|} \brAdd{\brTerm}{\brTerm}$
      \end{center}

      The function $\brEmbed{\row}$ describes the translation of $\row$ to this language.

      \begin{enumerate}
        \item $\brEmbed{\rEmpty} = 0$
        \item $\brEmbed{\rSingleton{\effect_i}} = \brVar_i$
        \item $\brEmbed{\rUnion{\row_1}{\row_2}} = \brAdd{\brAdd{\brEmbed{\row_1}}{\brEmbed{\row_2}}}{\parens{\brMul{\brEmbed{\row_1}}{\brEmbed{\row_2}}}}$
        \item $\brEmbed{\rDiff{\row_1}{\row_2}} = \brAdd{\brEmbed{\row_1}}{\parens{\brMul{\brEmbed{\row_1}}{\brEmbed{\row_2}}}}$
      \end{enumerate}

      Given $\row_1$ and $\row_2$, the algorithm returns true when $\brEmbed{\rDiff{\row_2}{\row_1}} = \brEmbed{\rEmpty}$.

      The intuition of the algorithm is to build a boolean term which corresponds to a propositional formula describing set inclusion on the effect row.

      \begin{figure}[H]
        \begin{mdframed}[backgroundcolor=none]
          \begin{center}
            \framebox{$\subtype{\type}{\type}$}
          \end{center}

          \medskip

          \begin{prooftree}
              \AxiomC{}
            \RightLabel{(\textsc{ST-Unit})}
            \UnaryInfC{$\subtype{\tUnit}{\tUnit}$}
          \end{prooftree}

          \begin{prooftree}
              \AxiomC{$\subtype{\type_3}{\type_1}$}
              \AxiomC{$\subtype{\type_2}{\type_4}$}
              \AxiomC{$\subrow{\row_1}{\row_2}$}
            \RightLabel{(\textsc{ST-Arrow})}
            \TrinaryInfC{$\subtype{\tArrow{\type_1}{\tEmbellished{\type_2}{\row_1}}}{\tArrow{\type_3}{\tEmbellished{\type_4}{\row_2}}}$}
          \end{prooftree}

          \caption{Subtyping rules}\label{fig:subtyping_rules}
        \end{mdframed}
      \end{figure}

    \subsection{Typing}

      \begin{figure}[H]
        \begin{mdframed}[backgroundcolor=none]
          \begin{center}
            \framebox{$\hasType{\context}{\term}{\tEmbellished{\type}{\row}}$}
          \end{center}

          \medskip

          \begin{prooftree}
              \AxiomC{}
            \RightLabel{(\textsc{T-Unit})}
            \UnaryInfC{$\hasType{\context}{\eUnit}{\tEmbellished{\tUnit}{\rEmpty}}$}
          \end{prooftree}

          \begin{prooftree}
              \AxiomC{$\apply{\context}{\eVar} = \tEmbellished{\type}{\row}$}
            \RightLabel{(\textsc{T-Variable})}
            \UnaryInfC{$\hasType{\context}{\eVar}{\tEmbellished{\type}{\row}}$}
          \end{prooftree}

          \begin{prooftree}
              \AxiomC{$\hasType{\cExtend{\context}{\anno{\eVar}{\tEmbellished{\type_1}{\rEmpty}}}}{\term}{\tEmbellished{\type_2}{\row_2}}$}
            \RightLabel{(\textsc{T-Abstraction})}
            \UnaryInfC{$\hasType{\context}{\parens{\eAbs{\anno{\eVar}{\type_1}}{\term}}}{\tEmbellished{\parens{\tArrow{\type_1}{\tEmbellished{\type_2}{\row_2}}}}{\rEmpty}}$}
          \end{prooftree}

          \begin{prooftree}
              \AxiomC{$\hasType{\context}{\term_1}{\tEmbellished{\type_1}{\row_1}}$}
              \AxiomC{$\hasType{\context}{\term_2}{\tEmbellished{\parens{\tArrow{\type_3}{\tEmbellished{\type_2}{\row_2}{}}}}{\row_3}}$}
              \AxiomC{$\subtype{\type_1}{\type_3}$}
            \RightLabel{(\textsc{T-Application})}
            \TrinaryInfC{$\hasType{\context}{\eApp{\term_2}{\term_1}}{\tEmbellished{\type_2}{\rUnion{\rUnion{\row_1}{\row_2}}{\row_3}}}$}
          \end{prooftree}

          \begin{prooftree}
              \AxiomC{\Shortstack[c]{
                {$\hasType{\context}{\term_1}{\tEmbellished{\type_1}{\row_1}}$}
                {$\hasType{\context}{\term_2}{\tEmbellished{\type_2}{\row_2}}$}
                {$\subtype{\type_1}{\substitute{\type_3}{\rSingleton{\effect}}{\bigcup_i \effect_i}}$}
                {$\subrow{\row_1}{\substitute{\row_3}{\rSingleton{\effect}}{\bigcup_i \effect_i}}$}
                {$\apply{\effectMap}{\effect} = \tEmbellished{\type_3}{\row_3}$}
              }}
            \RightLabel{(\textsc{T-Provide})}
            \UnaryInfC{$\hasType{\context}{\eProvide{\effect}{\overline{\effect_i}}{\term_1}{\term_2}}{\tEmbellished{\type_2}{\rUnion{\parens{\rDiff{\row_2}{\rSingleton{\effect}}}}{\effect_i}}}$}
          \end{prooftree}

          \caption{Typing rules}\label{fig:typing_rules}
        \end{mdframed}
      \end{figure}

      \begin{figure}[H]
        \begin{mdframed}[backgroundcolor=none]
          \begin{center}
            \framebox{$\eWellFormed{\emMap{\effect}{\tEmbellished{\type}{\row}}}$}
          \end{center}

          \medskip

          \begin{prooftree}
              \AxiomC{$\effect \in \row$}
            \RightLabel{(\textsc{WFE-Unit})}
            \UnaryInfC{$\eWellFormed{\emMap{\effect}{\tEmbellished{\tUnit}{\row}}}$}
          \end{prooftree}

          \begin{prooftree}
              \AxiomC{$\effect \in \row_2$}
            \RightLabel{(\textsc{WFE-Arrow1})}
            \UnaryInfC{$\eWellFormed{\emMap{\effect}{\tEmbellished{\parens{\tArrow{\type_1}{\tEmbellished{\type_2}{\row_1}}}}{\row_2}}}$}
          \end{prooftree}

          \begin{prooftree}
              \AxiomC{$\eWellFormed{\emMap{\effect}{\tEmbellished{\type_2}{\row_1}}}$}
            \RightLabel{(\textsc{WFE-Arrow2})}
            \UnaryInfC{$\eWellFormed{\emMap{\effect}{\tEmbellished{\parens{\tArrow{\type_1}{\tEmbellished{\type_2}{\row_1}}}}{\row_2}}}$}
          \end{prooftree}

          \caption{Effect well-formedness}\label{fig:effect_well_formedness}
        \end{mdframed}
      \end{figure}

\end{document}
